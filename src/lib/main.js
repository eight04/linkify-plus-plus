const {linkify, UrlMatcher, INVALID_TAGS} = require("linkify-plus-plus-core");
// NOTE: there is a weird transition flickering with :hover on Firefox
// const sentinel = require('sentinel-js'); // default

const MAX_PROCESSES = 100;
const processedNodes = new WeakSet;
const nodeValidationCache = new WeakMap; // Node -> boolean
let processes = 0;
const triggers = [
  {
    enabled: pref => pref.get("triggerByPageLoad"),
    trigger: async options => {
      await prepareDocument();
      processedNodes.add(document.body);
      await linkify({...options, root: document.body, recursive: true});
    }
  },
  {
    enabled: pref => pref.get("triggerByNewNode"),
    trigger: async options => {
      await prepareDocument();
      const observer = new MutationObserver(function(mutations){
        // Filter out mutations generated by LPP
        var lastRecord = mutations[mutations.length - 1],
          nodes = lastRecord.addedNodes,
          i;

        if (nodes.length >= 2) {
          for (i = 0; i < 2; i++) {
            if (nodes[i].className == "linkifyplus") {
              return;
            }
          }
        }

        for (var record of mutations) {
          for (const node of record.addedNodes) {
            if (node.nodeType === 1 && !processedNodes.has(node)) {
              if (processes >= MAX_PROCESSES) {
                throw new Error("Too many processes");
              }
              if (processedNodes.has(node)) {
                continue;
              }
              processedNodes.add(node);
              processes++;
              linkify({...options, root: node, recursive: true})
                .finally(() => {
                  processes--;
                });
            }
          }
        }
      });
      observer.observe(document.body, {
        childList: true,
        subtree: true
      });
    }
  },
  {
    enabled: pref => pref.get("triggerByHover"),
    trigger: options => {
      document.addEventListener("mouseover", function(e){
        const el = e.target;
        console.log(el, processedNodes.has(el))
        if (validRoot(el, options.validator)) {
          processedNodes.add(el);
          linkify({...options, root: el, recursive: false});
        }
      }, {
        passive: true
      });
    }
  },
  {
    enabled: pref => pref.get("triggerByClick"),
    trigger: options => {
      document.addEventListener("click", function(e){
        var el = e.target;
        if (validRoot(el, options.validator)) {
          processedNodes.add(el);
          linkify({...options, root: el, recursive: false});
        }
      }, {
        passive: true
      });
    }
  }
]

// Valid root node before linkifing
function validRoot(node, validator) {
  if (processedNodes.has(node)) {
    return false;
  }
  return getValidation(node);

  function getValidation(p) {
    if (!p.parentNode) {
      return false;
    }
    let r = nodeValidationCache.get(p);
    if (r === undefined) {
      if (validator.isIncluded(p)) {
        r = true;
      } else if (validator.isExcluded(p)) {
        r = false;
      } else if (p.parentNode != document.documentElement) {
        r = getValidation(p.parentNode);
      } else {
        r = true;
      }
      nodeValidationCache.set(p, r);
    }
    return r;
  }
}

function createValidator({includeElement, excludeElement}) {
  const f = function(node) {
    if (processedNodes.has(node)) {
      return false;
    }

    if (node.isContentEditable) {
      return false;
    }

    if (node.matches) {
      if (includeElement && node.matches(includeElement)) {
        return true;
      }
      if (excludeElement && node.matches(excludeElement)) {
        return false;
      }
    }
    return true;
  };
  f.isIncluded = node => {
    return includeElement && node.matches(includeElement);
  };
  f.isExcluded = node => {
    if (INVALID_TAGS[node.localName]) {
      return true;
    }
    return excludeElement && node.matches(excludeElement);
  };
  return f;
}

function stringToList(value) {
  value = value.trim();
  if (!value) {
    return [];
  }
  return value.split(/\s*\n\s*/g);  
}

function createOptions(pref) {
  const options = {};
  pref.on("change", update);
  update(pref.getAll());
  return options;
  
  function update(changes) {
    Object.assign(options, changes);
    options.validator = createValidator(options);
    if (typeof options.customRules === "string") {
      options.customRules = stringToList(options.customRules);
    }
    options.matcher = new UrlMatcher(options);
    options.onlink = options.embedImageExcludeElement ? onlink : null;
  }
  
  function onlink({link, range, content}) {
    if (link.childNodes[0].localName !== "img" || !options.embedImageExcludeElement) {
      return;
    }
    
    var parent = range.startContainer;
    // it might be a text node
    if (!parent.closest) {
      parent = parent.parentNode;
    }
    if (!parent.closest(options.embedImageExcludeElement)) return;
    // remove image
    link.innerHTML = "";
    link.appendChild(content);
  }
}

async function startLinkifyPlusPlus(getPref) {
  // Limit contentType to specific content type
  if (
    document.contentType &&
    !["text/plain", "text/html", "application/xhtml+xml"].includes(document.contentType)
  ) {
    return;
  }
  
  const pref = await getPref();
  const options = createOptions(pref);
  for (const trigger of triggers) {
    if (trigger.enabled(pref)) {
      trigger.trigger(options);
    }
  }
  // TODO: disable trigger when options change?
}

function prepareDocument() {
  // wait till everything is ready
  return prepareBody().then(prepareApp);
  
  function prepareApp() {
    const appRoot = document.querySelector("[data-server-rendered]");
    if (!appRoot) {
      return;
    }
    return new Promise(resolve => {
      const onChange = () => {
        if (!appRoot.hasAttribute("data-server-rendered")) {
          resolve();
          observer.disconnect();
        }
      };
      const observer = new MutationObserver(onChange);
      observer.observe(appRoot, {attributes: true});
    });
  }
  
  function prepareBody() {
    if (document.readyState !== "loading") {
      return Promise.resolve();
    }
    return new Promise(resolve => {
      // https://github.com/Tampermonkey/tampermonkey/issues/485
      document.addEventListener("DOMContentLoaded", resolve, {once: true});
    });
  }
}

module.exports = {startLinkifyPlusPlus};
